---
title: "Custom Modeling"
format: html
---
## Set up
```{r}
library(tidyverse)
# Load datasets
booze <- read.csv(here::here("data/grouped_data_booze.csv"))
DEAD <- read.csv(here::here("data/grouped_data_dead.csv"))
```
```{r}
# Custom Function for standardizing variables in set-up 
standardize <- function(x) {
  mean_x <- mean(x)
  sd_x <- sd(x)
  standardized <- (x - mean_x) / sd_x
  return(standardized)
}
```
```{r}
# Prep Booze R Us data by converting types and extracting date (year/month)
booze <- booze |>
  mutate(
    company = as.factor(company),
    date = as.Date(paste0(date, "-01")),
    year = as.numeric(format(date, "%Y")),
    month = as.numeric(format(date, "%m"))
  )
# Filter out smaller chains
booze_large_chains <- booze |>
  filter(num_stores >= 5)
DEAD <- read.csv(here::here("data/grouped_data_dead.csv"))
# Prep DEAD data by converting types and extracting date (year)
DEAD <- DEAD |>
  mutate(
    county = as.factor(county),
    alcohol_type = as.factor(alcohol_type),
    year = as.numeric(date)
  )
# Standardize population and year
DEAD <- DEAD |>
  mutate(
    population_scaled = standardize(population),
    year_scaled = standardize(year)
  )
# Creating one-hot encoding of dummy variables for categorical predictor
county_dummies <- model.matrix(~ county, data = DEAD)
county_dummies <- county_dummies[, -1]  # Remove intercept
alcohol_dummies <- model.matrix(~ alcohol_type, data = DEAD)
alcohol_dummies <- alcohol_dummies[, -1]
DEAD <- cbind(DEAD, county_dummies, alcohol_dummies)
```
# Custom Functions:
```{r}
# Create k-folds for cross validation
cross_validation_split <- function(dataset, k) {
  set.seed(40313)
  n <- nrow(dataset)
  groups <- 1:k
  assignments <- rep(c(groups), length.out=n)
  assignments <- sample(assignments)
  dataset[["cv_group"]] <- assignments
  return(dataset)
}
```
```{r}
# Create k-fold cross validation and return metrics
fit_cv <- function(dataset, predictor_cols, response, k=5) {
  df_cv <- cross_validation_split(dataset, k)
  r2_metrics <- c()
  rmse_metrics <- c()
  mse_metrics <- c()
  # Loop on each fold
  for(i in 1:k) {
    test_set <- df_cv[df_cv$cv_group == i, ]
    train_set <-  df_cv[df_cv$cv_group != i, ]
    # Training data
    X_train <- as.matrix(train_set[, predictor_cols])
    X_train <- cbind(intercept = 1, X_train)
    y_train <- as.matrix(train_set[, response])
    # Testing data
    X_test <- as.matrix(test_set[, predictor_cols])
    X_test <- cbind(intercept = 1, X_test)
    y_test <- as.vector(test_set[, response])
    # Fit model on training and evaluate on testing
    model <- fit_linear_model(X_train, y_train)
    test.predictions <- predict_linear(model, X_test)
    # Calculate all metrics
    r2_metrics <- c(r2_metrics, calculate_r2(y_test, test.predictions))
    rmse_metrics <- c(rmse_metrics, calculate_rmse(y_test, test.predictions))
    mse_metrics <- c(mse_metrics, calculate_mse(y_test, test.predictions))
  }
  # Return all metrics
  return(list(
    cv_r2 = mean(r2_metrics),
    cv_rmse = mean(rmse_metrics),
    cv_mse = mean(mse_metrics)
  ))
}
```
```{r}
# Fit linear regression model with matrices
fit_linear_model <- function(X, y) {
  XtX <- t(X) %*% X
  XtX_inv <- solve(XtX)
  Xty <- t(X) %*% y
  coefficients <- XtX_inv %*% Xty
  return(list(
    coefficients = as.vector(coefficients),
    feature_names = colnames(X)
  ))
}
# Predictions on fitted model
predict_linear <- function(model, X_new) {
  predictions <- X_new %*% model$coefficients
  return(as.vector(predictions))
}
# R^2 calculation
calculate_r2 <- function(y_true, y_pred) {
  ss_res <- sum((y_true - y_pred)^2)
  ss_tot <- sum((y_true - mean(y_true))^2)
  r2 <- 1 - (ss_res / ss_tot)
  return(r2)
}
# MSE calculation
calculate_mse <- function(y_true, y_pred) {
  squared_errors <- (y_true - y_pred)^2
  mse <- mean(squared_errors)
  return(mse)
}
# RMSE calculation
calculate_rmse <- function(y_true, y_pred) {
  mse <- calculate_mse(y_true, y_pred)
  rmse <- sqrt(mse)
  return(rmse)
}
```
# Booze Models
```{r}
# Test model with all stores
predictor_cols <- c("num_stores", "year", "month")
response <- "sum_sale_dollars"
results <- fit_cv(booze, predictor_cols, response, k = 10) # 10 fold CV
print(paste("CV R^2:", round(results$cv_r2, 4)))      
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
```
```{r}
# Test model with only large chains
predictor_cols <- c("num_stores", "year", "month")
response <- "sum_sale_dollars"
results <- fit_cv(booze_large_chains, predictor_cols, response, k = 10) # 10 fold CV
print(paste("CV R^2:", round(results$cv_r2, 4)))      
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
```
```{r}
# Final features: Number of stores (all stores), year and month (best performing)
predictor_cols <- c("num_stores", "year", "month")
response <- "sum_sale_dollars"
results <- fit_cv(booze, predictor_cols, response, k = 10)
# Output cross validation performance metrics
print(paste("CV R^2:", round(results$cv_r2, 4)))
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
# Fit final model
X <- as.matrix(booze[, predictor_cols])
X <- cbind(intercept = 1, X)
y <- as.matrix(booze[, response])
model <- fit_linear_model(X, y)
print(model)
```
# DEAD Models
```{r}
# Test model with population and year
predictor_cols <- c("population_scaled", "year_scaled")
response <- "sum_sale_dollars"
results <- fit_cv(DEAD, predictor_cols, response, k = 10) # 10 fold CV
print(paste("CV R^2:", round(results$cv_r2, 4)))
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
```
```{r}
# Test model with population and alcohol types
predictor_cols <- c("population_scaled", "alcohol_typeCOCKTAILS", "alcohol_typeGIN", 
                    "alcohol_typeLIQUEUR", "alcohol_typeRUM", "alcohol_typeSCHNAPPS", 
                    "alcohol_typeSCOTCH", "alcohol_typeTEQUILA", "alcohol_typeVODKA", 
                    "alcohol_typeWHISKEY")
response <- "sum_sale_dollars"
results <- fit_cv(DEAD, predictor_cols, response, k = 10) # 10 fold CV
print(paste("CV R^2:", round(results$cv_r2, 4)))
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
```
```{r}
# Test model with all predictors
predictor_cols <- c("population_scaled", "year_scaled", "alcohol_typeCOCKTAILS", 
                    "alcohol_typeGIN", "alcohol_typeLIQUEUR", "alcohol_typeRUM", 
                    "alcohol_typeSCHNAPPS", "alcohol_typeSCOTCH", "alcohol_typeTEQUILA", 
                    "alcohol_typeVODKA", "alcohol_typeWHISKEY")
response <- "sum_sale_dollars"
results <- fit_cv(DEAD, predictor_cols, response, k = 10)  # 10 fold CV
print(paste("CV R^2:", round(results$cv_r2, 4)))
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
```
Final DEAD model:
```{r}
# Final features: population and alcohol types (best performing)
predictor_cols <- c("population_scaled", "alcohol_typeCOCKTAILS", "alcohol_typeGIN", 
                    "alcohol_typeLIQUEUR", "alcohol_typeRUM", "alcohol_typeSCHNAPPS", 
                    "alcohol_typeSCOTCH", "alcohol_typeTEQUILA", "alcohol_typeVODKA", 
                    "alcohol_typeWHISKEY")
response <- "sum_sale_dollars"
results <- fit_cv(DEAD, predictor_cols, response, k = 10)
# Output cross validation performance metrics
print(paste("CV R^2:", round(results$cv_r2, 4)))
print(paste("CV RMSE:", round(results$cv_rmse, 2)))
print(paste("CV MSE:", round(results$cv_mse, 2)))
# Fit final model
X <- as.matrix(DEAD[, predictor_cols])
X <- cbind(intercept = 1, X)
y <- as.matrix(DEAD[, response])
model <- fit_linear_model(X, y)
print(model)
```